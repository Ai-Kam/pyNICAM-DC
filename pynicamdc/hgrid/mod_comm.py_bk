import toml
import numpy as np
from mpi4py import MPI
from mod_adm import adm
from mod_stdio import std
from mod_process import prc

class Comm:

    _instance = None

    #rellist_vindex = 6
    rellist_vindex = 8  #to use i j array instead of ij array
    I_recv_gridi  = 0
    I_recv_gridj  = 1   
    I_recv_rgn    = 2
    I_recv_prc    = 3
    I_send_gridi  = 4
    I_send_gridj  = 5
    I_send_rgn    = 6
    I_send_prc    = 7
    
    Recv_nlim = 20  # number limit of rank to receive data
    Send_nlim = 20  # number limit of rank to send data

    info_vindex = 3
    I_size      = 0
    I_prc_from  = 1
    I_prc_to    = 2
    
    list_vindex  = 6
    I_gridi_from = 0
    I_gridj_from = 1
    I_l_from     = 2
    I_gridi_to   = 3
    I_gridj_to   = 4
    I_l_to       = 5

    def __init__(self):

        self.Copy_nmax_r2r = 0
        self.Recv_nmax_r2r = 0
        self.Send_nmax_r2r = 0
        self.Copy_nmax_p2r = 0
        self.Recv_nmax_p2r = 0
        self.Send_nmax_p2r = 0
        self.Copy_nmax_r2p = 0
        self.Recv_nmax_r2p = 0
        self.Send_nmax_r2p = 0
        self.Singular_nmax = 0


    def COMM_setup(self, fname_in):

        if std.io_l: 
            with open(std.fname_log, 'a') as log_file:
                print("+++ Module[comm]/Category[common share]", file=log_file)        
                print(f"*** input toml file is ", fname_in, file=log_file)
 
        with open(fname_in, 'r') as  file:
            cnfs = toml.load(file)

        if 'commparam' not in cnfs:
            with open(std.fname_log, 'a') as log_file:
                print("*** commparam not found in toml file! STOP.", file=log_file)
                #stop

        else:
            self.COMM_apply_barrier = cnfs['commparam']['COMM_apply_barrier']  
            self.COMM_varmax = cnfs['commparam']['COMM_varmax']  
            #debug = cnfs['commparam']['debug']  
            #testonly = cnfs['commparam']['testonly']  

        if std.io_nml: 
            if std.io_l:
                with open(std.fname_log, 'a') as log_file: 
                    print(cnfs['commparam'],file=log_file)
        
#        if ( RP == DP ):
#            COMM_datatype = MPI_DOUBLE_PRECISION
#        elseif( RP == SP ) then
#            COMM_datatype = MPI_REAL
#        else    
#            write(*,*) 'xxx precision is not supportd'
#            call PRC_MPIstop
#        endif

        #adm = Adm()

        #print("adm.ADM_prc_me= ", adm.ADM_prc_me)     
        #if adm.RGNMNG_r2p_pl[adm.I_NPL] < 0 and adm.RGNMNG_r2p_pl[adm.I_SPL] < 0:
        #    self.COMM_pl = False  # Fortran .false. â†’ Python False

        # Equivalent to Fortran's write(IO_FID_LOG,*) statements
        if std.io_l:
            with open(std.fname_log, 'a') as log_file: 
                print("", file=log_file)  # Equivalent to blank write line
                print("====== communication information ======", file=log_file)

        self.COMM_list_generate()

        self.COMM_sortdest()


    def COMM_list_generate(self):
        print("COMM_list_generate")

        ginner = adm.ADM_gmax - adm.ADM_gmin + 1

        # Allocate rellist (Fortran allocate -> NumPy array initialization)
        self.rellist = np.empty((self.rellist_vindex, adm.ADM_gall * adm.ADM_lall), dtype=int)

        #cnt = 0
        cnt = -1  # Adjust for zero-based indexing in Python    

        for l in range(adm.ADM_lall):  
            rgnid = adm.RGNMNG_l2r[l]
            prc = adm.ADM_prc_me

            #print("rgnid= ", rgnid)
            #print("prc= ", prc)  

            # ---< South West >---
            # NE -> SW halo
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_SW, rgnid] == adm.I_NE:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_SW, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    #print("n= ", n)

                    cnt += 1

                    #i = adm.ADM_gmin - 1 + n
                    i = adm.ADM_gmin + n
                    j = adm.ADM_gmin - 1
                    #i_rmt = adm.ADM_gmin - 1 + n
                    i_rmt = adm.ADM_gmin + n
                    j_rmt = adm.ADM_gmax

                    self.rellist[self.I_recv_gridi, cnt] = i  #self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j  
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt #self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

            # SE -> SW halo (Southern Hemisphere, Edge of diamond)
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_SW, rgnid] == adm.I_SE:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_SW, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmin + n
                    j = adm.ADM_gmin - 1
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmax - n  # Reverse order

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt
                
            #---< North West >---
            # SE -> NW 
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_NW, rgnid] == adm.I_SE:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_NW, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmin - 1
                    j = adm.ADM_gmin + n
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmin + n

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

            # NE -> NW  (Northern Hemisphere, Edge of diamond)
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_NW, rgnid] == adm.I_NE:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_NW, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmin - 1
                    j = adm.ADM_gmin + n
                    i_rmt = adm.ADM_gmax - n  # Reverse order
                    j_rmt = adm.ADM_gmax

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

            #---< North East >---
            # SW -> NE 
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_NE, rgnid] == adm.I_SW:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_NE, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmin + n
                    j = adm.ADM_gmax + 1
                    i_rmt = adm.ADM_gmin + n
                    j_rmt = adm.ADM_gmin

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

            # NW -> NE  (Northern Hemisphere, Edge of diamond)
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_NE, rgnid] == adm.I_NW:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_NE, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmin + 1 + n  # Shift 1 grid !  (1,17) is handled as the north vertex. (2:17,17) is handled here (gl05rl01)
                    j = adm.ADM_gmax + 1
                    i_rmt = adm.ADM_gmin 
                    j_rmt = adm.ADM_gmax - n  # Reverse order

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

            #---< South East >---
            # NW -> SE 
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_SE, rgnid] == adm.I_NW:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_SE, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmax + 1
                    j = adm.ADM_gmin + n
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmin + n

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

            # SW -> SE  (Southern Hemisphere, Edge of diamond)
            if adm.RGNMNG_edge_tab[adm.I_DIR, adm.I_SE, rgnid] == adm.I_SW:
                rgnid_rmt = adm.RGNMNG_edge_tab[adm.I_RGNID, adm.I_SE, rgnid]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                for n in range(ginner):  # Adjust for zero-based indexing
                    cnt += 1

                    i = adm.ADM_gmax + 1
                    j = adm.ADM_gmin + 1 + n  # Shift 1 grid !!!!!
                    i_rmt = adm.ADM_gmax - n  # Reverse order
                    j_rmt = adm.ADM_gmin

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt


            #---< Vertex : link to the next next region >---
            # West Vertex
            if adm.RGNMNG_vert_num[adm.I_W, rgnid] == 4:  # 4 regions around the vertex
                rgnid_rmt = adm.RGNMNG_vert_tab[adm.I_RGNID, adm.I_W, rgnid, 2]  # 0 is yourself, 2 is the next next region when 4 regions around the vertex (clockwise)
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                cnt += 1

                i = adm.ADM_gmin - 1
                j = adm.ADM_gmin - 1

                if adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_W, rgnid, 2] == adm.I_N:
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmax
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_W, rgnid, 2] == adm.I_E:
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmax
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_W, rgnid, 2] == adm.I_S:
                    i_rmt = adm.ADM_gmax   
                    j_rmt = adm.ADM_gmin

                self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                self.rellist[self.I_recv_gridj, cnt] = j
                self.rellist[self.I_recv_rgn, cnt] = rgnid
                self.rellist[self.I_recv_prc, cnt] = prc
                self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                self.rellist[self.I_send_gridj, cnt] = j_rmt
                self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                self.rellist[self.I_send_prc, cnt] = prc_rmt

            # North Vertex
            if adm.RGNMNG_vert_num[adm.I_N, rgnid] == 4:
                rgnid_rmt = adm.RGNMNG_vert_tab[adm.I_RGNID, adm.I_N, rgnid, 2]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                # Known as north pole point (not the north pole of the Earth)
                if adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_N, rgnid, 2] == adm.I_W:   
                    cnt += 1

                    i = adm.ADM_gmin
                    j = adm.ADM_gmax + 1
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmin

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

                    #if(rgnid == 7):
                    #    print("0:cnt= ", cnt) 
                    #    print("i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt= ", i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt)

                # Unused vertex point    ! What for??
                cnt += 1

                i = adm.ADM_gmin - 1
                j = adm.ADM_gmax + 1

                if adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_N, rgnid, 2] == adm.I_W:
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmin + 1
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_N, rgnid, 2] == adm.I_N:
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmax
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_N, rgnid, 2] == adm.I_E:
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmax
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_N, rgnid, 2] == adm.I_S:
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmin

                self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                self.rellist[self.I_recv_gridj, cnt] = j
                self.rellist[self.I_recv_rgn, cnt] = rgnid
                self.rellist[self.I_recv_prc, cnt] = prc
                self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                self.rellist[self.I_send_gridj, cnt] = j_rmt
                self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                self.rellist[self.I_send_prc, cnt] = prc_rmt

                #if(rgnid == 7):
                #    print("cnt= ", cnt)
                #    print("i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt= ", i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt)

            # East Vertex
            if adm.RGNMNG_vert_num[adm.I_E, rgnid] == 4:
                if adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_E, rgnid, 2] == adm.I_W:
                    rgnid_rmt = adm.RGNMNG_vert_tab[adm.I_RGNID, adm.I_E, rgnid, 2]
                    prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                    cnt += 1

                    i = adm.ADM_gmax + 1
                    j = adm.ADM_gmax + 1
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmin

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

                    #if i == 17 and j == 17:
                    #    print("i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt= ", i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt)
                    #    print("cnt= ", cnt)

            # South Vertex        
            if adm.RGNMNG_vert_num[adm.I_S, rgnid] == 4:
                rgnid_rmt = adm.RGNMNG_vert_tab[adm.I_RGNID, adm.I_S, rgnid, 2]
                prc_rmt = adm.RGNMNG_r2lp[adm.I_prc, rgnid_rmt]

                # Known as south pole point (not the south pole of the Earth)
                if adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_S, rgnid, 2] == adm.I_W:
                    cnt += 1

                    i = adm.ADM_gmax + 1
                    j = adm.ADM_gmin
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmin

                    self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                    self.rellist[self.I_recv_gridj, cnt] = j
                    self.rellist[self.I_recv_rgn, cnt] = rgnid
                    self.rellist[self.I_recv_prc, cnt] = prc
                    self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                    self.rellist[self.I_send_gridj, cnt] = j_rmt
                    self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                    self.rellist[self.I_send_prc, cnt] = prc_rmt

                    #if i == 17 and j == 0:
                    #    print("oh, i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt= ", i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt)
                    #    print("cnt= ", cnt)

                # Unused vertex point   ! Again, what for??
                cnt += 1

                i = adm.ADM_gmax + 1
                j = adm.ADM_gmin - 1

                if adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_S, rgnid, 2] == adm.I_W:
                    i_rmt = adm.ADM_gmin + 1
                    j_rmt = adm.ADM_gmin
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_S, rgnid, 2] == adm.I_N:
                    i_rmt = adm.ADM_gmin
                    j_rmt = adm.ADM_gmax
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_S, rgnid, 2] == adm.I_E:
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmax
                elif adm.RGNMNG_vert_tab[adm.I_DIR, adm.I_S, rgnid, 2] == adm.I_S:
                    i_rmt = adm.ADM_gmax
                    j_rmt = adm.ADM_gmin

                self.rellist[self.I_recv_gridi, cnt] = i  # self.suf(i, j, adm)
                self.rellist[self.I_recv_gridj, cnt] = j
                self.rellist[self.I_recv_rgn, cnt] = rgnid
                self.rellist[self.I_recv_prc, cnt] = prc
                self.rellist[self.I_send_gridi, cnt] = i_rmt  # self.suf(i_rmt, j_rmt, adm)
                self.rellist[self.I_send_gridj, cnt] = j_rmt
                self.rellist[self.I_send_rgn, cnt] = rgnid_rmt
                self.rellist[self.I_send_prc, cnt] = prc_rmt

                #if i == 17 and j == 0:
                #    print("ohoh, i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt= ", i, j, rgnid, prc, i_rmt, j_rmt, rgnid_rmt, prc_rmt)
                #    print("cnt= ", cnt)
                #    print("adm.RGNMNG_vert_num[adm.I_S, rgnid]", adm.RGNMNG_vert_num[adm.I_S, rgnid])

        self.rellist_nmax = cnt + 1  # Adjust for zero-based indexing in Python

        if std.io_l:
            with open(std.fname_log, 'a') as log_file:
                print(f'*** rellist_nmax: {self.rellist_nmax}', file=log_file)

        debug = True
        if debug:
            if std.io_l:
                with open(std.fname_log, 'a') as log_file:
                    print('--- Relation Table', file=log_file)
                    print(f"{'Count':>10} {'|recv_gridi':>10} {'|recv_gridj':>10} {'|recv_rgn':>10} {'|recv_prc':>10} "
                          f"{'|send_gridi':>10} {'|send_gridj':>10} {'|send_rgn':>10} {'|send_prc':>10}", file=log_file)

                    for cnt in range(self.rellist_nmax):  # Adjust for zero-based indexing in Python
        #        if IO_L:
                        print(f"{cnt:10} {' '.join(f'{val:10}' for val in self.rellist[:, cnt])}", file=log_file)

        return


    #Sort data destination for region <-> region
    def COMM_sortdest(self):
        print("COMM_sortdest")

        # Allocate and initialize arrays
        self.Copy_info_r2r = np.full((self.info_vindex,), -1, dtype=int)
        self.Recv_info_r2r = np.full((self.info_vindex, self.Recv_nlim), -1, dtype=int)
        self.Send_info_r2r = np.full((self.info_vindex, self.Send_nlim), -1, dtype=int)

        # Set specific indices to 0
        self.Copy_info_r2r[self.I_size] = 0
        self.Recv_info_r2r[self.I_size, :] = 0
        self.Send_info_r2r[self.I_size, :] = 0

        # Allocate and initialize list arrays
        self.Copy_list_r2r = np.full((self.list_vindex, self.rellist_nmax), -1, dtype=int)
        self.Recv_list_r2r = np.full((self.list_vindex, self.rellist_nmax, self.Recv_nlim), -1, dtype=int)
        self.Send_list_r2r = np.full((self.list_vindex, self.rellist_nmax, self.Send_nlim), -1, dtype=int)

        print(f"self.Send_list_r2r.shape: {self.Send_list_r2r.shape}")
            


        # Sorting list according to destination
        for cnt in range(self.rellist_nmax):  

            if self.rellist[self.I_recv_prc, cnt] == self.rellist[self.I_send_prc, cnt]:  # No communication
                ipos = self.Copy_info_r2r[self.I_size] # Adjust for zero-based indexing in Python
                self.Copy_info_r2r[self.I_size] += 1

                self.Copy_list_r2r[self.I_gridi_from, ipos] = self.rellist[self.I_send_gridi, cnt]
                self.Copy_list_r2r[self.I_gridj_from, ipos] = self.rellist[self.I_send_gridj, cnt]
                #print("self.I_l_from= ", self.I_l_from)
                #print("self.rellist[self.I_send_rgn, cnt]= ", self.rellist[self.I_send_rgn, cnt])
                self.Copy_list_r2r[self.I_l_from, ipos] = adm.RGNMNG_r2lp[adm.I_l, self.rellist[self.I_send_rgn, cnt]]
                #print("self.Copy_list_r2r[self.I_l_from, ipos]= ", self.Copy_list_r2r[self.I_l_from, ipos])
                self.Copy_list_r2r[self.I_gridi_to, ipos] = self.rellist[self.I_recv_gridi, cnt]
                self.Copy_list_r2r[self.I_gridj_to, ipos] = self.rellist[self.I_recv_gridj, cnt]
                self.Copy_list_r2r[self.I_l_to, ipos] = adm.RGNMNG_r2lp[adm.I_l, self.rellist[self.I_recv_rgn, cnt]]

            else:  # Node-to-node communication
                # Search existing rank ID (identify by prc_from)
                irank = -1

                for n in range(self.Recv_nmax_r2r):
                    if self.Recv_info_r2r[self.I_prc_from, n] == self.rellist[self.I_send_prc, cnt]:
                        irank = n
                        break  # Equivalent to Fortran's 'exit'

                if irank < 0:  # Register new rank ID
                    irank = self.Recv_nmax_r2r  # Adjust for zero-based indexing in Python
                    self.Recv_nmax_r2r += 1             
                    #print(f"Rank {prc.comm_world.Get_rank()}: Recv_nmax_r2r = {self.Recv_nmax_r2r}")      
                    self.Recv_info_r2r[self.I_prc_from, irank] = self.rellist[self.I_send_prc, cnt]
                    self.Recv_info_r2r[self.I_prc_to, irank] = self.rellist[self.I_recv_prc, cnt]

                ipos = self.Recv_info_r2r[self.I_size, irank]  # Adjust for zero-based indexing in Python
                self.Recv_info_r2r[self.I_size, irank] += 1

                self.Recv_list_r2r[self.I_gridi_from, ipos, irank] = self.rellist[self.I_send_gridi, cnt]   
                self.Recv_list_r2r[self.I_gridj_from, ipos, irank] = self.rellist[self.I_send_gridj, cnt]
                self.Recv_list_r2r[self.I_l_from, ipos, irank] = adm.RGNMNG_r2lp[adm.I_l, self.rellist[self.I_send_rgn, cnt]] #####Checkp Looks good

                #r = self.rellist[self.I_send_rgn, cnt] 
                #l = adm.RGNMNG_r2lp[0, self.rellist[self.I_send_rgn, cnt]]
                #p = adm.RGNMNG_r2lp[1, self.rellist[self.I_send_rgn, cnt]]   
                #r2 = adm.RGNMNG_lp2r[l, p]
                #print("l, p, r = ", l, p, r, p*5+l, r2)   
                              
                #print("WOW!  self.I_l_from, ipos, irank= ", self.I_l_from, ipos, irank)
                #print("r: self.rellist[self.I_send_rgn, cnt]                    = ", self.rellist[self.I_send_rgn, cnt])
                #print("l: adm.RGNMNG_r2lp[0, self.rellist[self.I_send_rgn, cnt]]= ", adm.RGNMNG_r2lp[0, self.rellist[self.I_send_rgn, cnt]])
                #print("p: adm.RGNMNG_r2lp[1, self.rellist[self.I_send_rgn, cnt]]= ", adm.RGNMNG_r2lp[1, self.rellist[self.I_send_rgn, cnt]])
#                print("adm.RGNMNG_r2lp[adm.I_l, self.rellist[self.I_send_rgn, cnt]]= ", adm.RGNMNG_r2lp[adm.I_l, self.rellist[self.I_send_rgn, cnt]])
#                      self.I_l_from, ipos, irank= ", self.I_l_from, ipos, irank)   

                #print("check", self.Recv_list_r2r[self.I_l_from, ipos, irank], adm.I_l, self.rellist[self.I_send_rgn, cnt])
                self.Recv_list_r2r[self.I_gridi_to, ipos, irank] = self.rellist[self.I_recv_gridi, cnt]
                self.Recv_list_r2r[self.I_gridj_to, ipos, irank] = self.rellist[self.I_recv_gridj, cnt]
                self.Recv_list_r2r[self.I_l_to, ipos, irank] = adm.RGNMNG_r2lp[adm.I_l, self.rellist[self.I_recv_rgn, cnt]]


        if self.Copy_info_r2r[self.I_size] > 0:
            self.Copy_nmax_r2r = 1
            self.Copy_info_r2r[self.I_prc_from] = adm.ADM_prc_me
            self.Copy_info_r2r[self.I_prc_to] = adm.ADM_prc_me

        # Get maximum number of ranks for communication
        #self.sendbuf1[0] = self.Recv_nmax_r2r  # why is it defined as an array with only one component?
        #self.sendbuf1 = self.Recv_nmax_r2r  # Adjust for zero-based indexing in Python
        #call MPI_Allreduce(sendbuf1, recvbuf1, 1, MPI_INTEGER, MPI_MAX, MPI_COMM_WORLD, ierr)

        sendbuf1 = np.array([self.Recv_nmax_r2r], dtype=np.int32)  # Equivalent to sendbuf1(1)
        recvbuf1 = np.zeros(1, dtype=np.int32) 

        # Perform MPI_Allreduce to get the maximum value across all ranks
        prc.comm_world.Allreduce(sendbuf1, recvbuf1, op=MPI.MAX)

        # Store the result
        Recv_nglobal_r2r = recvbuf1[0]

        # Debugging print (optional)
        #print(f"Rank {prc.comm_world.Get_rank()}: Recv_nglobal_r2r = {Recv_nglobal_r2r}")
        #print("sendbuf1 & recvbuf1 = ", sendbuf1, recvbuf1) 


        # Allocate buffers
        sendbuf_info = np.full(self.info_vindex * Recv_nglobal_r2r, -1, dtype=np.int32)
        recvbuf_info = np.empty(self.info_vindex * Recv_nglobal_r2r * prc.prc_nprocs, dtype=np.int32)

        # Distribute receive request from each rank
        for irank in range(self.Recv_nmax_r2r):  # Adjust for zero-based indexing
            n = irank * self.info_vindex

            sendbuf_info[n + self.I_size] = self.Recv_info_r2r[self.I_size, irank]
            sendbuf_info[n + self.I_prc_from] = self.Recv_info_r2r[self.I_prc_from, irank]
            sendbuf_info[n + self.I_prc_to] = self.Recv_info_r2r[self.I_prc_to, irank]

        # Calculate total size
        totalsize = self.info_vindex * Recv_nglobal_r2r

        # Perform MPI_Allgather if totalsize > 0
        if totalsize > 0:
            prc.comm_world.Allgather(sendbuf_info, recvbuf_info)

        # Final assignment
        Send_size_nglobal = 0

        # Accept receive request to my rank
        print("Recv_nglobal_r2r * prc.prc_nprocs = ", Recv_nglobal_r2r * prc.prc_nprocs)
        print(Recv_nglobal_r2r, prc.prc_nprocs)
        for p in range(Recv_nglobal_r2r * prc.prc_nprocs):  # Adjust for zero-based indexing
            n = p * self.info_vindex

            if recvbuf_info[n + self.I_prc_from] == adm.ADM_prc_me:
#                self.Send_nmax_r2r += 1
                irank = self.Send_nmax_r2r
                self.Send_nmax_r2r += 1
                
                self.Send_info_r2r[self.I_size, irank] = recvbuf_info[n + self.I_size]

                #print("n, self.I_prc_from = ", n, self.I_prc_from)  #hahaha
                self.Send_info_r2r[self.I_prc_from, irank] = recvbuf_info[n + self.I_prc_from]
                #print(f"self.Send_info_r2r[self.I_prc_from, irank] = {self.Send_info_r2r[self.I_prc_from, irank]}")
                self.Send_info_r2r[self.I_prc_to, irank] = recvbuf_info[n + self.I_prc_to]

            Send_size_nglobal = max(Send_size_nglobal, recvbuf_info[n + self.I_size])

        # Print logging information if std.IO_L is enabled
        if std.io_l: 
            with open(std.fname_log, 'a') as log_file:
                print(file=log_file)
                print(f"*** Recv_nmax_r2r(global) = {Recv_nglobal_r2r}", file=log_file)
                print(f"*** Recv_nmax_r2r(local)  = {self.Recv_nmax_r2r}", file=log_file)
                print(f"*** Send_nmax_r2r(local)  = {self.Send_nmax_r2r}", file=log_file)
                print(f"*** Send_size_r2r(global) = {Send_size_nglobal}", file=log_file)
                print(file=log_file)

                print("|---------------------------------------", file=log_file)
                print("|               size  prc_from    prc_to", file=log_file)
                print(f"| Copy_r2r {''.join(f'{val:10}' for val in self.Copy_info_r2r)}", file=log_file)

                for irank in range(self.Recv_nmax_r2r):  
                    print(f"| Recv_r2r {''.join(f'{val:10}' for val in self.Recv_info_r2r[:, irank])}", file=log_file)

                for irank in range(self.Send_nmax_r2r):  
                    print(f"| Send_r2r {''.join(f'{val:10}' for val in self.Send_info_r2r[:, irank])}", file=log_file)


        # Allocate request list
        #REQ_list_r2r = np.empty(self.Recv_nmax_r2r + self.Send_nmax_r2r, dtype=MPI.Request)
        #REQ_list_r2r = [MPI.REQUEST_NULL] * (self.Recv_nmax_r2r + self.Send_nmax_r2r)
        REQ_list_r2r = np.empty(self.Recv_nmax_r2r + self.Send_nmax_r2r, dtype=object)
        REQ_list_r2r.fill(MPI.REQUEST_NULL)  # Initialize with NULL requests

        # Allocate send and receive buffers
        #print("hey", self.Recv_nmax_r2r, Send_size_nglobal, self.Send_nmax_r2r)
        sendbuf_list = np.full((self.list_vindex, Send_size_nglobal, self.Recv_nmax_r2r), -1, dtype=np.int32)
        recvbuf_list = np.empty((self.list_vindex, Send_size_nglobal, self.Send_nmax_r2r), dtype=np.int32)

        # Initialize request count
        REQ_count = 0

        # Non-blocking receive requests
        recv_slices = [] 
        #send_slices = [] 
        REQ_list_r2r = []
        
        for irank in range(self.Send_nmax_r2r):  # Adjust for zero-based indexing
            totalsize = self.Send_info_r2r[self.I_size, irank] * self.list_vindex
            #size1 = self.Send_info_r2r[self.I_size, irank]
            #size2 = self.list_vindex
            size2 = self.Send_info_r2r[self.I_size, irank]
            size1 = self.list_vindex
            rank = self.Send_info_r2r[self.I_prc_to, irank] 
            tag = self.Send_info_r2r[self.I_prc_from, irank] 
            #tag = irank

            print("recieving...")
            #print("totalsize= ", totalsize, "source rank=", rank, "tag= ", tag, "   irank= ", irank)   
            print("size1= ", size1, "size2= ", size2, "source rank=", rank, "tag= ", tag, "   irank= ", irank)   
            # MPI Irecv (Non-blocking receive)
            #REQ_list_r2r[REQ_count - 1] = prc.comm_world.Irecv(recvbuf_list[:, :, irank], source=rank, tag=tag)
            #print("REQ_count", REQ_count)
            recvslice = np.empty((size1,size2),dtype=np.int32)
            recvslice = np.ascontiguousarray(recvslice)
            recv_slices.append(recvslice) 
            #recvslice = np.ascontiguousarray(recvslice)
            #print(f"Rank {prc.prc_myrank} is expecting to receive into shape {recvslice.shape}")
            print("REQ_count (recv) =", REQ_count)

            REQ_list_r2r.append(prc.comm_world.Irecv(recv_slices[irank], source=rank, tag=tag))


            #REQ_list_r2r[REQ_count] = prc.comm_world.Irecv(
                #np.ascontiguousarray(recvbuf_list[:, :, irank]), source=rank, tag=tag)
                #np.ascontiguousarray(recvbuf_list[0:self.list_vindex, 0:Send_size_nglobal, irank]), source=rank, tag=tag)
                #np.ascontiguousarray(recvbuf_list[0:size1, 0:size2, irank])
            #    recvslice, source=rank, tag=tag)
            
            if True:
                if prc.prc_myrank == 4:
                    if rank == 0:
                        print("receiving from rank 0 to rank 4")
                        #testrecv = np.empty((5),dtype=np.int32)
                        testrecv = np.empty((3,8),dtype=np.int64)
                        #RL2 = prc.comm_world.Recv(testrecv, source=rank, tag=tag)
                        RL2 = [prc.comm_world.Irecv(testrecv, source=rank, tag=tag)]
                        print("RL2 upon recv = ", RL2) 
                        #print("haha")  
        
            
            #print("recvslice shape = ", recvslice.shape, recvslice.dtype)
            #recvslice = np.ascontiguousarray(recvslice)
            #recvbuf_list[0:size1, 0:size2, irank] = recvslice[0:size1, 0:size2]    
            
            #print("contiguous recvslice shape = ", recvslice.shape, recvslice.dtype)

            REQ_count += 1

        print("")   

        # Copy data and initiate non-blocking sends
        for irank in range(self.Recv_nmax_r2r):  # Adjust for zero-based indexing
            for ipos in range(self.Recv_info_r2r[self.I_size, irank]):
                sendbuf_list[:, ipos, irank] = self.Recv_list_r2r[:, ipos, irank]    ##### Check this line

                #print("sendbuf_list: ", sendbuf_list[:, ipos, irank])#, ipos, irank)  #hahaha

            totalsize = self.Recv_info_r2r[self.I_size, irank] * self.list_vindex
            #size1 = self.Recv_info_r2r[self.I_size, irank] 
            #size2 = self.list_vindex
            size2 = self.Recv_info_r2r[self.I_size, irank] 
            size1 = self.list_vindex
            rank = self.Recv_info_r2r[self.I_prc_from, irank]
            tag  = rank #self.Recv_info_r2r[self.I_prc_from, irank] 

            #if rank == 2:
            #    if irank == 3:
            #        print("tag", tag)
            #        print("REQ_list_r2r[REQ_count]", REQ_list_r2r[REQ_count]) 
            #        print("irank, sendbuf_list: ", irank, sendbuf_list[:, :, irank])
            # MPI Isend (Non-blocking send)
            #print("REQ_count", REQ_count)
            #print("REQ_list_r2r[REQ_count]", REQ_list_r2r[REQ_count])

            print("sending...")
            #print("totalsize= ", totalsize, "dest rank=", rank, "tag= ", tag, "   irank= ", irank)   
            print("size1= ", size1, "size2= ", size2, "dest rank=", rank, "tag= ", tag, "   irank= ", irank)  
            sendslice = np.empty((size1,size2),dtype=np.int32)
            sendslice = np.ascontiguousarray(sendbuf_list[0:size1, 0:size2, irank])
            #send_slices.append(sendslice) 
            
            #print("sendslice shape = ", sendslice.shape, sendslice.dtype)
            #print("Sending slice:\n", sendslice)
            print("REQ_count (send) =", REQ_count)
            #REQ_list_r2r[REQ_count] = prc.comm_world.Isend(
                #np.ascontiguousarray(sendbuf_list[:, :, irank]), dest=rank, tag=tag)
                #np.ascontiguousarray(sendbuf_list[:, :, irank]), dest=rank, tag=tag)
                #np.ascontiguousarray(sendbuf_list[0:self.list_vindex, 0:Send_size_nglobal, irank]), dest=rank, tag=tag)
            #    sendslice, dest=rank, tag=tag)
            
            #REQ_list_r2r.append(prc.comm_world.Isend(send_slices[irank], dest=rank, tag=tag))
            REQ_list_r2r.append(prc.comm_world.Isend(sendslice, dest=rank, tag=tag))
            #REQ_list_r2r.append(prc.comm_world.Irecv(recv_slices[irank], source=rank, tag=tag))
            #self.list_vindex, Send_size_nglobal
            #print("REQ_list_r2r[REQ_count]", REQ_list_r2r[REQ_count])

            if True:
                if prc.prc_myrank == 0:
                    if tag == 4:
                        print("sending from rank 0 to rank 4")
                        testsendrandom_3d = np.random.randint(0, 10, (5, 11, 4))
                        print("test3d before send  ")
                        print(testsendrandom_3d)
                        #testsend = np.array([1,2,8,4,5],dtype=np.int32)
                        testsend2d = np.ascontiguousarray(testsendrandom_3d[0:3, 0:8, 2]) 
                        print("test before sending testsend2d: ", testsend2d)
                        #RL1 = prc.comm_world.Send(testsend2d, dest=rank, tag=tag)
                        RL1 = [prc.comm_world.Isend(testsend2d, dest=rank, tag=tag)]
                        print(testsend2d.shape, testsend2d.dtype, "!!!!!!")
                        print("RL1 upon send = ", RL1)

            if False:
                if prc.prc_myrank == 0:
                    if tag == 4:
                        print("tag", tag)
                        print("REQ_list_r2r[REQ_count]", REQ_list_r2r[REQ_count]) 
                        print("rank, irank= ", rank, irank)
                        print("sendbuf_list: ")
                        print(sendbuf_list[:, :, irank])
                        print("")#print("rank, irank, recvbuf_list: ", rank, irank, recvbuf_list[:, :, irank])
                        print("sendbuf_list shitei: ")
                        print(sendbuf_list[:, 0:self.Recv_info_r2r[self.I_size, irank], irank])
                                                
                        print("")#print("rank, irank, recvbuf_list: ", rank, irank, recvbuf_list[:, :, irank])
                        print("sendbuf_list shitei2: ", size1, size2, irank)
                        print(sendbuf_list[0:size1, 0:size2, irank])

                        for ipos in range(self.Recv_info_r2r[self.I_size, irank]): 
                            print("ipos= ", ipos)
                            print("sendbuf_list 1line")
                            print(sendbuf_list[:, ipos, irank])
                            print("self.Recv_list_r2r 1line")
                            print(self.Recv_list_r2r[:, ipos, irank])


            REQ_count += 1

            if False:
                if prc.prc_myrank == 4:
                    #if irank == 0:
                    print(RL2)
                    MPI.Request.Waitall(RL1)
                    #MPI.Request.Waitall(RL2)
                    #print("testsend: ", testsend)        

            if True:
                if prc.prc_myrank == 4:
                    if irank == 0:
                        MPI.Request.Waitall(RL2)
                        #MPI.Request.Wait(RL2)
                        print("testrecv: ", testrecv, "!!!!!!!!")    
            #MPI.Request.Wait(RL1)
            #MPI.Request.Wait(RL2)
            #print("testrecv: ", testrecv)     


        # Wait for all MPI requests to complete
        if self.Recv_nmax_r2r + self.Send_nmax_r2r > 0:
            print("list length", self.Recv_nmax_r2r + self.Send_nmax_r2r)
            MPI.Request.Waitall(REQ_list_r2r)
            #MPI.Request.Waitall(REQ_list_r2r[0:self.Recv_nmax_r2r + self.Send_nmax_r2r])  # from 0 to Recv + Send -1
            #MPI.Request.Waitall(REQ_list_r2r)  # from 0 to Recv + Send -1
            #pass

            
        
        #prc.comm_world.Barrier()

        # Store received data
        for irank in range(self.Send_nmax_r2r):  
            size2 = self.Send_info_r2r[self.I_size, irank]
            size1 = self.list_vindex
            #size1=
            #size2=self.Send_info_r2r[self.I_size]
            recvbuf_list[0:size1,0:size2,irank]=recv_slices[irank] #(recvslice)
            #if True:
            #    if prc.prc_myrank == 4:
            #        if irank == 0:
            #        for ipos in range(self.Send_info_r2r[self.I_size, irank]):

            #print("self.Send_info_r2r[self.I_size, irank]", self.Send_info_r2r[self.I_size, irank])

            #recvbuf_list[:, , irank] 

            for ipos in range(self.Send_info_r2r[self.I_size, irank]):
                self.Send_list_r2r[:, ipos, irank] = recvbuf_list[:, ipos, irank]
                #self.Send_list_r2r[0:6, ipos, irank] = recvbuf_list[0:6, ipos, irank]

                if False:
                    if prc.prc_myrank == 4:
                        if irank == 0:
                            print("irank, ipos= ", irank, ipos)
                            print("recvbuflist")
                            print(recvbuf_list[:, ipos, irank])
                            print("recvslice")
                            print(recvslice[:,:])

            if True:
                if prc.prc_myrank == 4:
                    if irank == 0:
                        print("recvbuflist 2d")
                        print(recvbuf_list[0:6, 0:34, irank])

                #print("ipos, irank, recvbuf_list: ", ipos, irank, recvbuf_list[:, ipos, irank])
                ####print("ha0", recvbuf_list[:, ipos, irank])
                      #self.Send_list_r2r[self.I_l_from, ipos, irank]) #ha0#
                #print("ha1", recvbuf_list[self.I_l_from, ipos, irank]) #self.Send_list_r2r[self.I_l_from, ipos, irank]) #ha0#
        #debug section


        debug = True 
        if debug:
            if std.io_l:
                with open(std.fname_log, 'a') as log_file:
                    print(file=log_file)
                    print("--- Copy_list_r2r", file=log_file)
                    print(file=log_file)
                    print(f"{'number':>6} {'|ifrom':>6} {'|jfrom':>6} {'|rfrom':>6} {'|lfrom':>6} {'|pfrom':>6} "
                          f"{'|  ito':>6} {'|  jto':>6} {'|  rto':>6} q{'|  lto':>6} {'|  pto':>6}", file=log_file)

                    for ipos in range(self.Copy_info_r2r[self.I_size]):
                        gi_from = self.Copy_list_r2r[self.I_gridi_from, ipos]
                        gj_from = self.Copy_list_r2r[self.I_gridj_from, ipos]
                        l_from = self.Copy_list_r2r[self.I_l_from, ipos]
                        p_from = self.Copy_info_r2r[self.I_prc_from]
                        #i_from = (g_from - 1) % adm.ADM_gall_1d + 1
                        #j_from = (g_from - i_from) // ADM_gall_1d + 1
                        r_from = adm.RGNMNG_lp2r[l_from, p_from]

                        gi_to = self.Copy_list_r2r[self.I_gridi_to, ipos]
                        gj_to = self.Copy_list_r2r[self.I_gridj_to, ipos]
                        l_to = self.Copy_list_r2r[self.I_l_to, ipos]
                        p_to = self.Copy_info_r2r[self.I_prc_to]
                        #i_to = (g_to - 1) % ADM_gall_1d + 1
                        #j_to = (g_to - i_to) // ADM_gall_1d + 1
                        r_to = adm.RGNMNG_lp2r[l_to, p_to]

                        print(f"{ipos:6} {gi_from:6} {gj_from:6} {r_from:6} {l_from:6} {p_from:6} "
                              f"{gi_to:6} {gj_to:6} {r_to:6} {l_to:6} {p_to:6}", file=log_file)

                    print(file=log_file)
                    print("--- Recv_list_r2r", file=log_file)

                    for irank in range(self.Recv_nmax_r2r):
                        print(f"{'number':>6} {'|ifrom':>6} {'|jfrom':>6} {'|rfrom':>6} {'|lfrom':>6} {'|pfrom':>6} "
                              f"{'|  ito':>6} {'|  jto':>6} {'|  rto':>6} {'|  lto':>6} {'|  pto':>6}", file=log_file)

                        for ipos in range(self.Recv_info_r2r[self.I_size, irank]):
                            gi_from = self.Recv_list_r2r[self.I_gridi_from, ipos, irank]
                            gj_from = self.Recv_list_r2r[self.I_gridj_from, ipos, irank]
                            l_from = self.Recv_list_r2r[self.I_l_from, ipos, irank]
                            p_from = self.Recv_info_r2r[self.I_prc_from, irank]
                            #i_from = (g_from - 1) % ADM_gall_1d + 1
                            #j_from = (g_from - i_from) // ADM_gall_1d + 1
                            r_from = adm.RGNMNG_lp2r[l_from, p_from]

                            gi_to = self.Recv_list_r2r[self.I_gridi_to, ipos, irank]
                            gj_to = self.Recv_list_r2r[self.I_gridj_to, ipos, irank]
                            l_to = self.Recv_list_r2r[self.I_l_to, ipos, irank]
                            p_to = self.Recv_info_r2r[self.I_prc_to, irank]
                            #i_to = (g_to - 1) % ADM_gall_1d + 1
                            #j_to = (g_to - i_to) // ADM_gall_1d + 1
                            r_to = adm.RGNMNG_lp2r[l_to, p_to]

                            print(f"{ipos:6} {gi_from:6} {gj_from:6} {r_from:6} {l_from:6} {p_from:6} "
                                  f"{gi_to:6} {gj_to:6} {r_to:6} {l_to:6} {p_to:6}", file=log_file)

                    print(file=log_file)
                    print("--- Send_list_r2r", file=log_file)

                    for irank in range(self.Send_nmax_r2r):
                        print(f"{'number':>6} {'|ifrom':>6} {'|jfrom':>6} {'|rfrom':>6} {'|lfrom':>6} {'|pfrom':>6} "
                              f"{'|  ito':>6} {'|  jto':>6} {'|  rto':>6} {'|  lto':>6} {'|  pto':>6}", file=log_file)
                        print("prc.prc_myrank= ", prc.prc_myrank)
                        print("irank= ", irank)
                        print("self.Send_info_r2r[self.I_size, irank]", self.Send_info_r2r[self.I_size, irank])
                        #print("self.Send_info_r2r[self.I_prc_from, irank]", self.Send_info_r2r[self.I_prc_from, irank])
                        for ipos in range(self.Send_info_r2r[self.I_size, irank]):
                            gi_from = self.Send_list_r2r[self.I_gridi_from, ipos, irank]
                            gj_from = self.Send_list_r2r[self.I_gridj_from, ipos, irank]
                            l_from = self.Send_list_r2r[self.I_l_from, ipos, irank]
                            p_from = self.Send_info_r2r[self.I_prc_from, irank]
                            #print("self.I_prc_from, irank= ", self.I_prc_from, irank)
                            #print("p_from", p_from)
                            #print("ipos, irank= ", ipos, irank)
                            #print(self.Send_list_r2r[self.I_l_from, ipos, irank])
                            #print("l_from", l_from)
                            #i_from = (g_from - 1) % ADM_gall_1d + 1
                            #j_from = (g_from - i_from) // ADM_gall_1d + 1
                            #print(f"l_from, p_from = {l_from}, {p_from}")
                            #print("ipos, irank= ", ipos, irank, l_from, p_from)
                            r_from = adm.RGNMNG_lp2r[l_from, p_from]
                            gi_to = self.Send_list_r2r[self.I_gridi_to, ipos, irank]
                            gj_to = self.Send_list_r2r[self.I_gridj_to, ipos, irank]
                            l_to = self.Send_list_r2r[self.I_l_to, ipos, irank]
                            p_to = self.Send_info_r2r[self.I_prc_to, irank]
                            #i_to = (g_to - 1) % ADM_gall_1d + 1
                            #j_to = (g_to - i_to) // ADM_gall_1d + 1
                            r_to = adm.RGNMNG_lp2r[l_to, p_to]

                            print(f"{ipos:6} {gi_from:6} {gj_from:6} {r_from:6} {l_from:6} {p_from:6} "
                                  f"{gi_to:6} {gj_to:6} {r_to:6} {l_to:6} {p_to:6}", file=log_file)



        # end of debug section

        # Allocate buffers
#        self.sendbuf_r2r_SP = np.empty((Send_size_nglobal * adm.ADM_kall * self.COMM_varmax, self.Send_nmax_r2r), dtype=np.float32)
#        self.recvbuf_r2r_SP = np.empty((Send_size_nglobal * adm.ADM_kall * self.COMM_varmax, self.Recv_nmax_r2r), dtype=np.float32)
#        self.sendbuf_r2r_DP = np.empty((Send_size_nglobal * adm.ADM_kall * self.COMM_varmax, self.Send_nmax_r2r), dtype=np.float64)
#        self.recvbuf_r2r_DP = np.empty((Send_size_nglobal * adm.ADM_kall * self.COMM_varmax, self.Recv_nmax_r2r), dtype=np.float64)

        return

    def COMM_sortdest_pl(self):
        pass

    def COMM_sortdest_singular(self):
        pass

    #def suf(self, i, j, adm):
    #    return adm.ADM_gall_1d * j + i 
